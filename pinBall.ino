#include <SPI.h>
#include <Gamebuino.h>
Gamebuino gb;


const byte background[] PROGMEM = {88,48,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x7F,0xFE,0xDA,0x40,0xFF,0xD0,0x0,0x0,0x0,0x70,0x0,0x0,0xFE,0xA,0xA0,0xFF,0xA0,0x0,0x0,0x0,0xF8,0x0,0x0,0xE,0xF9,0x20,0xFF,0x41,0xFF,0xF0,0x1,0x6C,0x0,0x0,0x1,0xF8,0x0,0xFE,0x82,0x0,0x0,0x1,0x4,0x3F,0x80,0x0,0x79,0x0,0xFD,0x4,0x0,0x0,0x1,0x7C,0xF,0xFF,0x0,0x3A,0x80,0xFA,0x8,0x0,0x0,0x0,0xF8,0x0,0x7F,0xF0,0x3A,0x80,0xF4,0x10,0xFF,0xFC,0x0,0x70,0x0,0x0,0xFC,0x18,0x0,0xE8,0x21,0xFF,0xFE,0x0,0x0,0x0,0x0,0xE,0x19,0x0,0xD0,0x1,0xF0,0x0,0x0,0x0,0x0,0x0,0x6,0x1A,0x80,0xA0,0x1,0xC0,0x0,0x0,0x0,0x0,0x0,0x6,0x19,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x8,0x0,0x80,0x0,0x1,0xF0,0x0,0x0,0x0,0x0,0x3,0xB,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x8,0x80,0x0,0x1,0xF0,0x0,0x0,0x70,0x0,0x1C,0x1,0x8,0x80,0x0,0x0,0x0,0x0,0x0,0xF8,0x0,0x3E,0x1,0x8,0x0,0x0,0x0,0x1,0xF0,0x1,0x14,0x0,0x55,0x0,0xB,0x80,0x0,0x0,0x0,0x0,0x1,0x54,0x0,0x55,0x0,0xA,0x80,0x0,0x1,0xF0,0x0,0x1,0x44,0x0,0x41,0x0,0xA,0x0,0x0,0x0,0x0,0x0,0x0,0xF8,0x0,0x3E,0x0,0x8,0x0,0x0,0x0,0x1,0xF0,0x0,0x70,0x0,0x1C,0x0,0xA,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x1,0xF0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x1,0xF0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x1,0xF0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x70,0x0,0x0,0x0,0x8,0x0,0x80,0x0,0x1,0xF0,0x0,0xF8,0x0,0x0,0x0,0x8,0x0,0x40,0x0,0x0,0x0,0x1,0x6C,0x0,0x0,0x0,0x8,0x0,0xA0,0x1,0xC0,0x0,0x1,0x4,0x0,0x3E,0x18,0x8,0x0,0xD0,0x1,0xF0,0x0,0x1,0x7C,0x1,0xD5,0xC,0x8,0x0,0xE8,0x21,0xFF,0xFE,0x0,0xF8,0xF,0xD5,0xC,0x8,0x0,0xF4,0x10,0xFF,0xFC,0x0,0x70,0x7,0xC1,0xE,0x8,0x0,0xFA,0x8,0x0,0x0,0x0,0x0,0x3,0xFF,0xE,0x8,0x0,0xFD,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0xE,0x18,0x0,0xFE,0x82,0x0,0x0,0x0,0x0,0x20,0x0,0xE,0x18,0x0,0xFF,0x41,0xFF,0xF0,0x0,0x0,0x30,0x0,0x1C,0x18,0x0,0xFF,0xA0,0x0,0x0,0x0,0x0,0x3C,0x0,0xF8,0x18,0x0,0xFF,0xD0,0x0,0x0,0x0,0x0,0x3F,0xFF,0xF0,0x38,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x3F,0xFF,0x0,0x38,0x0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x0,0x78,0x0,0xFF,0xF8,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xF8,0x0,0xFF,0xF8,0x0,0x0,0x0,0x0,0x0,0x0,0xF,0xF8,0x0,0xFF,0xF8,0x0,0x0,0x0,0x0,0x0,0x0,0xFF,0xF8,0x0,0xFF,0xF8,0x0,0x0,0x0,0x0,0x0,0x7F,0xFF,0xF8,0x0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0x0,};
const byte ball[] PROGMEM = {8,4,0x60,0xF0,0xD0,0x60,};
const byte flipperBas[] PROGMEM = {8,7,0x60,0x60,0xE0,0xC0,0xC0,0x80,0x80,};
const byte flipperHaut[] PROGMEM = {8,6,0x40,0xE0,0x20,0x30,0x18,0x4,};
const byte ressortBAs[] PROGMEM = {8,4,0x8,0x58,0xA8,0x8,};
const byte ressortHaut[] PROGMEM = {16,4,0x0,0x40,0xAA,0xC0,0x55,0x40,0x0,0x40,};

byte vieRestante = 2;
boolean isRessortHaut = true;
boolean isLeftFlipperPressed = false;
boolean isRightFlipperPressed = false;
float gravite = -0.2;
float forceRessort = 6;
#define MAX_VITESSE_BALL 6
#define TIME_FORCE  5
byte timeForce = 0;

typedef struct{
  int8_t x1,y1,x2,y2;
} Droite;

Droite droites[21] = {
  {0,0,84,0},
  {0,13,11,0},
  {10,9,15,4},
  {16,4,27,4},
  {16,11,19,9},
  {20,9,30,9},
  {50,5,70,9},
  {71,9,71,16},
  {66,0,75,8},
  {75,8,75,40},
  {67,30,70,36},
  {70,36,65,40},
  {65,40,10,42},
  {10,42,10,48},
  {10,48,66,48},
  {66,48,75,40},
  {0,29,12,42},
  {9,33,16,38},
  {16,38,27,38},
  {15,30,20,33},
  {20,33,30,33}
};

typedef struct{
  float x, y, r, vx, vy;
} Circle;

Circle Ball;



boolean collideDroite(Droite d2,Droite *d3);

void setup()
{
  gb.begin();
  goTitleScreen();
  gb.setFrameRate(60);//60
}

void initGame()
{
  gb.battery.show = false;
  vieRestante = 2;
  Ball.x = 40;
  Ball.y = 43;
}


void loop()
{
 if(gb.update())
 {
   updateWorld();
   updateBall();
   drawBall();
   drawWorld();
 }
}

void updateWorld()
{
  if(timeForce>0)
  {
    timeForce--;
  }
  isRessortHaut = true;
  isLeftFlipperPressed = false;
  isRightFlipperPressed = false;
  if(gb.buttons.repeat(BTN_LEFT,1))
  {
    isRessortHaut = false;
     
    timeForce = TIME_FORCE;
  }
  if(gb.buttons.repeat(BTN_UP,1))
  {
    isLeftFlipperPressed = true;
  }
  if(gb.buttons.repeat(BTN_DOWN,1))
  {
    isRightFlipperPressed = true;
  }
}

void updateBall()
{
  Ball.vx += gravite; 
  if(abs(Ball.vx)>MAX_VITESSE_BALL) Ball.vx = (Ball.vx>0)? MAX_VITESSE_BALL: -MAX_VITESSE_BALL ;
  if(gb.collideRectRect(13,43,((isRessortHaut)? 10 : 5),4,Ball.x,Ball.y,2,2))
  {
    if(isRessortHaut)
    {
      if(timeForce>0)
      {
        float percent = 1 - ((Ball.x - 18)/5);
        float force = forceRessort * percent;    
        Ball.vx += force;
        //Ball.vy -= 0.001;
        Ball.x = 23;
      }
    }
    else 
    {
        Ball.x = 18;
    }
    
    if(Ball.vx<0)
    {
      Ball.vx = -Ball.vx*0.5;
    }
  }
  for(byte i=0;i<21;i++)
  {
    Droite * dret;
    if(collideDroite(droites[i],dret))
    {
      //Ball.vx *= -0.8;     
      //break;
      float dx = (droites[i].x1 - droites[i].x2);
      float dy = (droites[i].y1 - droites[i].y2);
      
      float N = atan(dy/dx); //angle of the normal to te collision plane
        if(dx < 0){
          N += PI;
        }

        //Note that the tangent speed of the collisions are computed even if not used in this example.

        //CIRCLE I
        //composant of the speed normal to the collision plane of circle i
        //float Vin = circles[i].vx * cos(N) + circles[i].vy * sin(N);
        //the composant of Vin on x and y
        //float Vinx = Vin * cos(N);
        //float Viny = Vin * sin(N);

        //CIRCLE J
        //composant of the speed normal to the collision plane of circle j
        float Vjn = Ball.vx * cos(N) + Ball.vy * sin(N);
        //the composant of Vin on x and y
        float Vjnx = Vjn * cos(N);
        float Vjny = Vjn * sin(N);


        //CIRCLE
        Ball.vx += - Vjnx;// + Vinx;
        Ball.vy += Vjny;// + Viny;

        //move the first circle to the surface of the second to avoid it getting stuck inside
        //Ball.x = dret->x1;
        //Ball.y = dret->y1;
        
    }
  }
  
  Ball.x += Ball.vx;
  Ball.y += Ball.vy;
  
  //prevent circles from going out of the screen :
  /*if(circles[i].x < 0){
    circles[i].vx *= -1;
    circles[i].x = 0;
  }*/
  /*
  if(Ball.x > LCDWIDTH){
    Ball.vx *= -1;
    Ball.x = LCDWIDTH;
  }

  if(Ball.y < 0){
    Ball.vy *= -1;
    Ball.y = 0;
  }
  if(Ball.y > LCDHEIGHT){
    Ball.vy *= -1;
    Ball.y = LCDHEIGHT;
  } */
   
  if(Ball.x<-5)
  {
    Ball.vx = 0;
    Ball.vy = 0;
    Ball.x = 40;
    Ball.y = 43;
  }
}

void drawBall()
{
  gb.display.drawBitmap(Ball.x,Ball.y, ball);
}

void drawWorld()
{
  
  /*for(byte i=0;i<21;i++)
  {
    gb.display.drawLine(droites[i].x1, droites[i].y1, droites[i].x2, droites[i].y2);
  }*/
  
  gb.display.drawBitmap(0,0,background);
  gb.display.drawBitmap(8,24, ((isRightFlipperPressed)? flipperHaut : flipperBas),0,FLIPV);
  gb.display.drawBitmap(8,11, ((isLeftFlipperPressed)? flipperHaut : flipperBas));
  gb.display.drawBitmap(13,43, ((isRessortHaut)? ressortHaut : ressortBAs));
  gb.display.setColor(INVERT);
  for(byte i=0;i<vieRestante;i++)
  {
    gb.display.drawBitmap(2+ (i*5),43, ball);
  }
  gb.display.setColor(BLACK);
}

boolean collideDroite(Droite d2,Droite *d3)
 {
  Droite d1;
  d1.x1 = Ball.x + 2;
  d1.y1 = Ball.y + 2;
  d1.x2 = d1.x1 + Ball.vx;
  d1.y2 = d1.y1 + Ball.vy;
  
  float  distAB, theCos, theSin, newX, ABpos ;
  if (d1.x1==d1.x2 && d1.y1==d1.y2 || d2.x1==d2.x2 && d2.y1==d2.y2) return false;

  //  Fail if the segments share an end-point.
  if (d1.x1==d2.x1 && d1.y1==d2.y1 || d1.x2==d2.x1 && d1.y2==d2.y1
  ||  d1.x1==d2.x2 && d1.y1==d2.y2 || d1.x2==d2.x2 && d1.y2==d2.y2) {
    return false; }

  //  (1) Translate the system so that point A is on the origin.
  d1.x2-=d1.x1; d1.y2-=d1.y1;
  d2.x1-=d1.x1; d2.y1-=d1.y1;
  d2.x2-=d1.x1; d2.y2-=d1.y1;

  //  Discover the length of segment A-B.
  distAB=sqrt(d1.x2*d1.x2+d1.y2*d1.y2);

  //  (2) Rotate the system so that point B is on the positive X axis.
  theCos=d1.x2/distAB;
  theSin=d1.y2/distAB;
  newX=d2.x1*theCos+d2.y1*theSin;
  d2.y1  =d2.y1*theCos-d2.x1*theSin; d2.x1=newX;
  newX=d2.x2*theCos+d2.y2*theSin;
  d2.y2  =d2.y2*theCos-d2.x2*theSin; d2.x2=newX;

  //  Fail if segment C-D doesn't cross line A-B.
  if (d2.y1<0. && d2.y2<0. || d2.y1>=0. && d2.y2>=0.) return false;

  //  (3) Discover the position of the intersection point along line A-B.
  ABpos=d2.x2+(d2.x1-d2.x2)*d2.y2/(d2.y2-d2.y1);

  //  Fail if segment C-D crosses line A-B outside of segment A-B.
  if (ABpos<0. || ABpos>distAB) return false;

  //  (4) Apply the discovered position to line A-B in the original coordinate system.
  d3->x1=d1.x1+ABpos*theCos;
  d3->y1=d1.y1+ABpos*theSin;

  //  Success.
  return true; 
}


